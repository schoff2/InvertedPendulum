// c:\workspace\InvertedPendulum\ReinforcementLearning\deploy\inference.cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <chrono>
#include <thread>
#include <mutex>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <linux/i2c-dev.h>
#include <linux/i2c.h>
#include <sys/ioctl.h>
#include <stdint.h>
#include <signal.h>

// Include the weights generated by export_model.py
#include "policy_weights.h"

// ------------------------------------------------------------------
// Neural Network Primitives
// ------------------------------------------------------------------

// --- FPGA Memory Map ---
#define LWHPS2FPGA_BASE 0xFF200000
#define LWHPS2FPGA_SPAN 0x00000040 

// --- HPS Reset Manager ---
#define RSTMGR_BASE      0xFFD05000
#define RSTMGR_SPAN      0x1000
#define RSTMGR_BRGMODRST 0x1C

// Register Offsets
#define REG_TARGET_SPEED 0x00
#define REG_TARGET_POS   0x04
#define REG_ACCEL_VAL    0x08
#define REG_MAX_SPEED    0x0C
#define REG_MIN_LIMIT    0x10
#define REG_MAX_LIMIT    0x14
#define REG_CURR_SPEED   0x18
#define REG_POS_COUNTER  0x1C
#define REG_HOME_SWITCH  0x20

// --- Hardware Settings ---
const int AS5048_ADDR = 0x40;
const float homingSpeed = -3000.0;
const float maxAccel = 400000.0;
const float maxMotorSpeed = 100000.0;
const int total_track_steps = 26120;
const int safety_margin = 300;
const int min_limit = -total_track_steps / 2 + safety_margin;
const int max_limit = total_track_steps / 2 - safety_margin;
const float STEPS_PER_METER = 40000.0f;

// Global state
void* virtual_base;
int i2c_fd;

// --- FPGA Register Helpers ---
void write_reg(uint32_t offset, int32_t value) {
    *(volatile int32_t*)((uint8_t*)virtual_base + offset) = value;
}

int32_t read_reg(uint32_t offset) {
    return *(volatile int32_t*)((uint8_t*)virtual_base + offset);
}

void signalHandler(int signum) {
    if (virtual_base != MAP_FAILED && virtual_base != nullptr) {
        write_reg(REG_TARGET_SPEED, 0);
    }
    std::cout << "\nCaught signal " << signum << ", stopping motor..." << std::endl;
    exit(signum);
}

// --- Bridge Control ---
void enable_lwhps_bridge() {
    int fd = open("/dev/mem", O_RDWR | O_SYNC);
    if (fd < 0) return;
    void* rstmgr = mmap(NULL, RSTMGR_SPAN, PROT_READ | PROT_WRITE, MAP_SHARED, fd, RSTMGR_BASE);
    if (rstmgr != MAP_FAILED) {
        uint32_t* brgmodrst = (uint32_t*)((uint8_t*)rstmgr + RSTMGR_BRGMODRST);
        *brgmodrst &= ~(0x2);
        munmap(rstmgr, RSTMGR_SPAN);
    }
    close(fd);
}

// --- I2C Sensor Reading ---
uint16_t read14BitAngle() {
    struct i2c_rdwr_ioctl_data packets;
    struct i2c_msg messages[2];
    uint8_t reg = 0xFE;
    uint8_t data[2] = {0};

    messages[0].addr = AS5048_ADDR;
    messages[0].flags = 0;
    messages[0].len = 1;
    messages[0].buf = &reg;

    messages[1].addr = AS5048_ADDR;
    messages[1].flags = I2C_M_RD;
    messages[1].len = 2;
    messages[1].buf = data;

    packets.msgs = messages;
    packets.nmsgs = 2;

    if (ioctl(i2c_fd, I2C_RDWR, &packets) < 0) return 0;
    return ((uint16_t)data[0] << 6) | (data[1] & 0x3F);
}

float getPhysicalAngle(float initialAngle) {
    uint16_t raw = read14BitAngle();
    float degrees = raw * 0.02197265625;
    float diff = degrees - initialAngle;
    if (diff > 180.0f) diff -= 360.0f;
    if (diff < -180.0f) diff += 360.0f;
    return diff;
}

inline float activation_tanh(float x) {
    return std::tanh(x);
}

// Performs: output = activation(weights * input + bias)
// Template arguments used for compile-time loop unrolling/optimization
template <int ROWS, int COLS>
void dense_layer(const float input[COLS], 
                 float output[ROWS], 
                 const float weights[ROWS][COLS], 
                 const float bias[ROWS], 
                 bool use_activation) {
    for (int i = 0; i < ROWS; ++i) {
        float sum = bias[i];
        for (int j = 0; j < COLS; ++j) {
            sum += weights[i][j] * input[j];
        }
        
        if (use_activation) {
            output[i] = activation_tanh(sum);
        } else {
            output[i] = sum;
        }
    }
}

// ------------------------------------------------------------------
// Policy Inference
// ------------------------------------------------------------------

// Frame Stacking Configuration
const int RAW_OBS_SIZE = 4; // [x, x_dot, theta, theta_dot]
const int STACK_SIZE = L0_IN / RAW_OBS_SIZE;

// Buffers for intermediate layer outputs
// We use static buffers to avoid dynamic allocation on embedded systems
static float l0_out[L0_OUT];
static float l1_out[L1_OUT];
static float action_out[L2_OUT];
static float obs_buffer[L0_IN]; // Buffer to hold the stacked observations

// Reset the observation buffer (e.g. at start of episode)
// Fills the entire stack with the initial observation
void reset_observation_buffer(const float init_obs[RAW_OBS_SIZE]) {
    for (int i = 0; i < STACK_SIZE; ++i) {
        for (int j = 0; j < RAW_OBS_SIZE; ++j) {
            obs_buffer[i * RAW_OBS_SIZE + j] = init_obs[j];
        }
    }
}

// Update the buffer with a new observation
// Shifts old observations to the left and appends the new one
void update_observation_buffer(const float new_obs[RAW_OBS_SIZE]) {
    // Shift existing data to the left (discarding the oldest frame)
    // Move elements from [RAW_OBS_SIZE ... L0_IN-1] to [0 ... L0_IN-RAW_OBS_SIZE-1]
    for (int i = 0; i < (STACK_SIZE - 1) * RAW_OBS_SIZE; ++i) {
        obs_buffer[i] = obs_buffer[i + RAW_OBS_SIZE];
    }

    // Copy new observation to the end of the buffer
    int offset = (STACK_SIZE - 1) * RAW_OBS_SIZE;
    for (int j = 0; j < RAW_OBS_SIZE; ++j) {
        obs_buffer[offset + j] = new_obs[j];
    }
}

/**
 * Run the policy network.
 * @param state  Input array [x, x_dot, theta, theta_dot]
 * @param action Output array [acceleration]
 */
void predict_action(const float state[L0_IN], float action[L2_OUT]) {
    // --- Layer 0: Input -> Hidden 1 ---
    // SB3 Default: Linear -> Tanh
    dense_layer<L0_OUT, L0_IN>(state, l0_out, L0_W, L0_B, true);
    
    // --- Layer 1: Hidden 1 -> Hidden 2 ---
    // SB3 Default: Linear -> Tanh
    dense_layer<L1_OUT, L1_IN>(l0_out, l1_out, L1_W, L1_B, true);
    
    // --- Layer 2: Hidden 2 -> Output ---
    // SB3 Default: Linear (Mean of Gaussian) -> No Activation
    dense_layer<L2_OUT, L2_IN>(l1_out, action_out, L2_W, L2_B, false);
    
    // --- Output Clipping ---
    // Clip to valid action range [-1.0, 1.0]
    for(int i = 0; i < L2_OUT; ++i) {
        action[i] = std::max(-1.0f, std::min(1.0f, action_out[i]));
    }
}

// ------------------------------------------------------------------
// Main (Example Usage)
// ------------------------------------------------------------------

int main() {
    signal(SIGINT, signalHandler);
    signal(SIGSEGV, signalHandler);
    signal(SIGABRT, signalHandler);

    std::cout << "--- DE10-Nano RL Inference Engine ---" << std::endl;

    // Verify dimensions
    if (L0_IN % RAW_OBS_SIZE != 0) {
        std::cerr << "Error: Model input size " << L0_IN 
                  << " is not divisible by raw observation size " << RAW_OBS_SIZE << std::endl;
        return -1;
    }
    std::cout << "Model Input: " << L0_IN << " | Stack Size: " << STACK_SIZE << std::endl;

    // --- Hardware Initialization ---
    enable_lwhps_bridge();

    int mem_fd = open("/dev/mem", O_RDWR | O_SYNC);
    virtual_base = mmap(NULL, LWHPS2FPGA_SPAN, PROT_READ | PROT_WRITE, MAP_SHARED, mem_fd, LWHPS2FPGA_BASE);

    i2c_fd = open("/dev/i2c-1", O_RDWR);
    ioctl(i2c_fd, I2C_SLAVE, AS5048_ADDR);

    // --- Homing ---
    std::cout << "Homing..." << std::endl;
    write_reg(REG_ACCEL_VAL, 100000);
    write_reg(REG_MAX_SPEED, 10000);
    write_reg(REG_MIN_LIMIT, 0x80000000);
    write_reg(REG_MAX_LIMIT, 0x7FFFFFFF);
    write_reg(REG_TARGET_SPEED, (int32_t)homingSpeed);
    while (read_reg(REG_HOME_SWITCH) == 0) usleep(1000);
    write_reg(REG_TARGET_SPEED, 0);

    write_reg(REG_POS_COUNTER, 0);
    write_reg(REG_TARGET_POS, (int32_t)(total_track_steps / 2));
    while(read_reg(REG_POS_COUNTER) < (total_track_steps / 2)) usleep(1000);
    write_reg(REG_POS_COUNTER, 0);
    write_reg(REG_TARGET_POS, 0);
    write_reg(REG_MIN_LIMIT, (int32_t)min_limit);
    write_reg(REG_MAX_LIMIT, (int32_t)max_limit);

    // --- Zero Angle ---
    float initialAngle = 331.65;  //331.26;// Calibrated UP value
    std::cout << "Initial Angle: " << initialAngle << std::endl;

    write_reg(REG_ACCEL_VAL, (int32_t)maxAccel);
    write_reg(REG_MAX_SPEED, (int32_t)maxMotorSpeed);

    // --- Control Loop ---
    float startAngle = getPhysicalAngle(initialAngle);
    int32_t startPosSteps = read_reg(REG_POS_COUNTER);
    float startPos = startPosSteps / STEPS_PER_METER;

    float raw_state[4] = {startPos, 0.0f, startAngle * (float)(M_PI / 180.0f), 0.0f}; 
    float action[1] = {0.0f};
    float lastAngle = startAngle;
    float lastPos = startPos;
    
    // Reset buffer
    reset_observation_buffer(raw_state);

    auto lastTime = std::chrono::high_resolution_clock::now();
    const float DT = 0.005f; // 5ms
    const int FRAME_SKIP = 4; // Match simulation training
    int step_counter = 0;

    std::cout << "Starting Control Loop..." << std::endl;

    while (true) {
        auto now = std::chrono::high_resolution_clock::now();
        std::chrono::duration<float> elapsed = now - lastTime;
        float dt = elapsed.count();

        if (dt >= DT) {
            lastTime = now;
            auto start_compute = std::chrono::high_resolution_clock::now();

            // 1. Read Sensors
            float currentAngle = getPhysicalAngle(initialAngle);
            int32_t currentPosSteps = read_reg(REG_POS_COUNTER);
            float currentPos = currentPosSteps / STEPS_PER_METER;

            // 2. Calculate Derivatives
            float deltaAngle = currentAngle - lastAngle;
            if (deltaAngle > 180.0f)  deltaAngle -= 360.0f;
            if (deltaAngle < -180.0f) deltaAngle += 360.0f;
            float theta_dot = (deltaAngle / dt) * (M_PI / 180.0f);
            
            float x_dot = (currentPos - lastPos) / dt;

            lastAngle = currentAngle;
            lastPos = currentPos;

            // 3. Update State [x, x_dot, theta, theta_dot]
            raw_state[0] = currentPos;
            raw_state[1] = x_dot;
            raw_state[2] = currentAngle * (M_PI / 180.0f);
            raw_state[3] = theta_dot;

            // 4. Inference (Decimated)
            // Only run inference every FRAME_SKIP steps (20ms)
            // The action remains constant between inferences
            if (step_counter % FRAME_SKIP == 0) {
                update_observation_buffer(raw_state);
                predict_action(obs_buffer, action);
            }
            step_counter++;

            // 5. Actuation
            // Action is now Target Speed (normalized [-1, 1])
            float target_speed = action[0] * maxMotorSpeed;
            
            // Clamp speed
            if (target_speed > maxMotorSpeed) target_speed = maxMotorSpeed;
            if (target_speed < -maxMotorSpeed) target_speed = -maxMotorSpeed;

            // Rail safety
            if (currentPosSteps > (max_limit - 1000) && target_speed > 0) target_speed = 0;
            if (currentPosSteps < (min_limit + 1000) && target_speed < 0) target_speed = 0;

            write_reg(REG_TARGET_SPEED, (int32_t)target_speed);

            auto end_compute = std::chrono::high_resolution_clock::now();
            std::chrono::duration<float, std::micro> compute_time = end_compute - start_compute;
            
            static int debug_cnt = 0;
            if (debug_cnt++ % 200 == 0) {
                std::cout << "Compute: " << compute_time.count() << " us" << std::endl;
            }
            if (compute_time.count() > 4000.0f) {
                std::cout << "SLOW LOOP: " << compute_time.count() << " us" << std::endl;
            }
        }
    }

    // Cleanup (unreachable in infinite loop, but handled by signalHandler)
    write_reg(REG_TARGET_SPEED, 0);
    munmap(virtual_base, LWHPS2FPGA_SPAN);
    close(mem_fd);
    close(i2c_fd);
    return 0;
}
